name: Sync to Target Repos

on:
  push:
    branches: [main]
    paths:
      - ".claude/**"
  workflow_dispatch:
    inputs:
      target_repos:
        description: "Comma-separated repos to sync (e.g., owner/repo1,owner/repo2). Empty = all repos."
        required: false
        type: string

permissions:
  contents: read

jobs:
  discover:
    runs-on: ubuntu-latest
    outputs:
      matrix: ${{ steps.build-matrix.outputs.matrix }}
      has-repos: ${{ steps.build-matrix.outputs.has-repos }}
    steps:
      - name: Generate GitHub App JWT
        id: app-jwt
        env:
          APP_ID: ${{ secrets.APP_ID }}
          APP_PRIVATE_KEY: ${{ secrets.APP_PRIVATE_KEY }}
        run: |
          # Generate JWT for GitHub App authentication
          NOW=$(date +%s)
          IAT=$((NOW - 60))
          EXP=$((NOW + 600))

          # Write private key to temp file
          KEY_FILE=$(mktemp)
          printf '%s' "$APP_PRIVATE_KEY" | sed -e $'s/\\\\n/\\\n/g' > "$KEY_FILE"

          # Create JWT header and payload
          HEADER=$(printf '%s' '{"alg":"RS256","typ":"JWT"}' | base64 -w 0 | tr -d '=' | tr '/+' '_-')
          PAYLOAD=$(printf '%s' "{\"iat\":${IAT},\"exp\":${EXP},\"iss\":\"${APP_ID}\"}" | base64 -w 0 | tr -d '=' | tr '/+' '_-')

          # Sign with private key
          SIGNATURE=$(printf '%s' "${HEADER}.${PAYLOAD}" | openssl dgst -sha256 -sign "$KEY_FILE" -binary | base64 -w 0 | tr -d '=' | tr '/+' '_-')

          rm -f "$KEY_FILE"

          JWT="${HEADER}.${PAYLOAD}.${SIGNATURE}"
          echo "::add-mask::${JWT}"
          echo "jwt=${JWT}" >> "$GITHUB_OUTPUT"

      - name: Build repository matrix
        id: build-matrix
        env:
          APP_JWT: ${{ steps.app-jwt.outputs.jwt }}
          TARGET_REPOS: ${{ inputs.target_repos }}
        run: |
          # Get all installations
          echo "Getting all installations..."
          installations_response=$(curl -s --max-time 30 -w '\n%{http_code}' \
            -H "Authorization: Bearer $APP_JWT" \
            -H "Accept: application/vnd.github+json" \
            https://api.github.com/app/installations)
          http_code="${installations_response##*$'\n'}"
          installations_body="${installations_response%$'\n'*}"

          if [ "$http_code" != "200" ]; then
            echo "::error::Failed to get installations (HTTP $http_code)"
            exit 1
          fi

          # Build installation lookup: owner -> installation_id
          declare -A owner_to_installation
          while IFS=: read -r inst_id owner; do
            owner_to_installation["$owner"]="$inst_id"
          done < <(echo "$installations_body" | jq -r '.[] | "\(.id):\(.account.login)"')

          echo "Found ${#owner_to_installation[@]} installations"

          # Build matrix array
          matrix_items=()

          if [ -n "$TARGET_REPOS" ]; then
            # Single-repo mode: use specified repos
            echo "Mode: Single-repo (target: $TARGET_REPOS)"
            IFS=',' read -ra target_repos_array <<< "$TARGET_REPOS"

            for repo in "${target_repos_array[@]}"; do
              repo=$(echo "$repo" | xargs)  # Trim whitespace
              owner="${repo%%/*}"
              repo_name="${repo#*/}"

              installation_id="${owner_to_installation[$owner]:-}"
              if [ -z "$installation_id" ]; then
                echo "::warning::No installation found for owner $owner"
                continue
              fi

              matrix_items+=("{\"repo\":\"$repo\",\"owner\":\"$owner\",\"repo_name\":\"$repo_name\",\"installation_id\":\"$installation_id\"}")
            done
          else
            # All-repos mode: get repos from all installations
            echo "Mode: All-repos"

            for owner in "${!owner_to_installation[@]}"; do
              installation_id="${owner_to_installation[$owner]}"

              # Get installation token
              token_response=$(curl -s --max-time 30 -w '\n%{http_code}' -X POST \
                -H "Authorization: Bearer $APP_JWT" \
                -H "Accept: application/vnd.github+json" \
                "https://api.github.com/app/installations/${installation_id}/access_tokens")
              http_code="${token_response##*$'\n'}"
              token_body="${token_response%$'\n'*}"
              token=$(echo "$token_body" | jq -r '.token')

              if [ "$http_code" != "201" ] || [ -z "$token" ] || [ "$token" = "null" ]; then
                echo "::warning::Failed to get token for installation $installation_id"
                continue
              fi
              echo "::add-mask::${token}"

              # Get repos for this installation
              repos_response=$(curl -s --max-time 30 -w '\n%{http_code}' \
                -H "Authorization: Bearer $token" \
                -H "Accept: application/vnd.github+json" \
                https://api.github.com/installation/repositories)
              repos_http_code="${repos_response##*$'\n'}"
              repos_body="${repos_response%$'\n'*}"

              if [ "$repos_http_code" != "200" ]; then
                echo "::warning::Failed to get repos for installation $installation_id"
                continue
              fi

              # Add each repo to matrix
              while IFS= read -r repo; do
                [ -z "$repo" ] && continue
                repo_name="${repo#*/}"
                matrix_items+=("{\"repo\":\"$repo\",\"owner\":\"$owner\",\"repo_name\":\"$repo_name\",\"installation_id\":\"$installation_id\"}")
              done < <(echo "$repos_body" | jq -r '.repositories[].full_name')
            done
          fi

          # Build final matrix JSON
          if [ ${#matrix_items[@]} -eq 0 ]; then
            echo "No repositories found"
            echo "has-repos=false" >> "$GITHUB_OUTPUT"
            echo "matrix={\"include\":[]}" >> "$GITHUB_OUTPUT"
          else
            echo "Found ${#matrix_items[@]} repositories to sync"
            matrix_json=$(printf '%s\n' "${matrix_items[@]}" | jq -sc '{include: .}')
            echo "has-repos=true" >> "$GITHUB_OUTPUT"
            echo "matrix=$matrix_json" >> "$GITHUB_OUTPUT"
          fi

  sync:
    needs: discover
    if: needs.discover.outputs.has-repos == 'true'
    runs-on: ubuntu-latest
    strategy:
      fail-fast: false
      max-parallel: 5
      matrix: ${{ fromJson(needs.discover.outputs.matrix) }}
    steps:
      - name: Generate token for ${{ matrix.repo }}
        id: app-token
        uses: actions/create-github-app-token@v2
        with:
          app-id: ${{ secrets.APP_ID }}
          private-key: ${{ secrets.APP_PRIVATE_KEY }}
          owner: ${{ matrix.owner }}
          repositories: ${{ matrix.repo_name }}

      - name: Checkout target repo
        uses: actions/checkout@v4
        with:
          repository: ${{ matrix.repo }}
          token: ${{ steps.app-token.outputs.token }}
          path: target

      - name: Checkout config source
        uses: actions/checkout@v4
        with:
          path: _config_source

      - name: Install yq
        run: |
          sudo wget -qO /usr/local/bin/yq https://github.com/mikefarah/yq/releases/latest/download/yq_linux_amd64
          sudo chmod +x /usr/local/bin/yq

      - name: Sync config files
        id: sync
        run: |
          chmod +x _config_source/scripts/sync-files.sh
          _config_source/scripts/sync-files.sh _config_source target

      - name: Get config version
        id: version
        if: steps.sync.outputs.changed == 'true'
        run: |
          cd _config_source
          echo "sha=$(git rev-parse --short HEAD)" >> "$GITHUB_OUTPUT"

      - name: Create verified commit with deletions
        if: steps.sync.outputs.changed == 'true'
        env:
          GH_TOKEN: ${{ steps.app-token.outputs.token }}
          TARGET_REPO: ${{ matrix.repo }}
          CONFIG_REPO: ${{ github.repository }}
        run: |
          cd target
          BRANCH_NAME="chore/update-claude-config"
          OWNER="${TARGET_REPO%%/*}"
          REPO="${TARGET_REPO#*/}"

          # Get base commit (try branch first, fall back to default branch)
          get_ref_sha() {
            local ref="$1"
            local sha
            sha=$(gh api "repos/${OWNER}/${REPO}/git/refs/heads/${ref}" --jq '.object.sha' 2>/dev/null) || return 1
            # Validate it looks like a SHA (40 hex chars)
            [[ "$sha" =~ ^[0-9a-f]{40}$ ]] && echo "$sha" && return 0
            return 1
          }

          BASE_SHA=$(get_ref_sha "$BRANCH_NAME" || get_ref_sha "main" || get_ref_sha "master")
          if [[ -z "$BASE_SHA" ]]; then
            echo "Error: Could not find base branch"
            exit 1
          fi

          BASE_TREE=$(gh api "repos/${OWNER}/${REPO}/git/commits/${BASE_SHA}" --jq '.tree.sha')
          if [[ ! "$BASE_TREE" =~ ^[0-9a-f]{40}$ ]]; then
            echo "Error: Could not get base tree from commit ${BASE_SHA}"
            exit 1
          fi

          echo "Base commit: $BASE_SHA"
          echo "Base tree: $BASE_TREE"

          # Build tree entries from staged changes
          TREE_ENTRIES="[]"

          # Process staged files (additions and modifications)
          while IFS= read -r file; do
            [ -z "$file" ] && continue
            if [ -f "$file" ]; then
              # File exists - create blob and add to tree
              CONTENT=$(base64 -w0 "$file")
              BLOB_SHA=$(gh api "repos/${OWNER}/${REPO}/git/blobs" \
                -f content="$CONTENT" \
                -f encoding="base64" \
                --jq '.sha')
              # Get file mode (100644 for regular, 100755 for executable)
              if [ -x "$file" ]; then
                MODE="100755"
              else
                MODE="100644"
              fi
              TREE_ENTRIES=$(echo "$TREE_ENTRIES" | jq --arg path "$file" --arg sha "$BLOB_SHA" --arg mode "$MODE" \
                '. + [{"path": $path, "mode": $mode, "type": "blob", "sha": $sha}]')
            fi
          done < <(git diff --cached --name-only --diff-filter=AM)

          # Process deletions (sha: null removes from tree)
          while IFS= read -r file; do
            [ -z "$file" ] && continue
            TREE_ENTRIES=$(echo "$TREE_ENTRIES" | jq --arg path "$file" \
              '. + [{"path": $path, "mode": "100644", "type": "blob", "sha": null}]')
          done < <(git diff --cached --name-only --diff-filter=D)

          echo "Tree entries: $(echo "$TREE_ENTRIES" | jq length)"

          # Create new tree
          NEW_TREE=$(gh api "repos/${OWNER}/${REPO}/git/trees" \
            --field base_tree="$BASE_TREE" \
            --input <(echo "$TREE_ENTRIES" | jq '{tree: .}') \
            --jq '.sha')

          echo "New tree: $NEW_TREE"

          # Create commit (signed automatically when using App token)
          COMMIT_MSG="chore(config): update Claude config

          Updated configuration from ${CONFIG_REPO}."

          NEW_COMMIT=$(gh api "repos/${OWNER}/${REPO}/git/commits" \
            -f message="$COMMIT_MSG" \
            -f tree="$NEW_TREE" \
            -f "parents[]=$BASE_SHA" \
            --jq '.sha')

          echo "New commit: $NEW_COMMIT"

          # Update or create branch ref
          if gh api "repos/${OWNER}/${REPO}/git/refs/heads/${BRANCH_NAME}" --silent 2>/dev/null; then
            # Branch exists - update it
            gh api "repos/${OWNER}/${REPO}/git/refs/heads/${BRANCH_NAME}" \
              -X PATCH \
              -f sha="$NEW_COMMIT" \
              -F force=true
          else
            # Branch doesn't exist - create it
            gh api "repos/${OWNER}/${REPO}/git/refs" \
              -f ref="refs/heads/${BRANCH_NAME}" \
              -f sha="$NEW_COMMIT"
          fi

          echo "Branch ${BRANCH_NAME} updated to ${NEW_COMMIT}"

      - name: Create or update PR
        if: steps.sync.outputs.changed == 'true'
        env:
          GH_TOKEN: ${{ steps.app-token.outputs.token }}
          DIFF_STAT: ${{ steps.sync.outputs.diff_stat }}
          CHANGED_FILES: ${{ steps.sync.outputs.changed_files }}
          CONFIG_REPO: ${{ github.repository }}
          CONFIG_SHA: ${{ steps.version.outputs.sha }}
          TARGET_REPO: ${{ matrix.repo }}
        run: |
          cd target
          BRANCH_NAME="chore/update-claude-config"

          # Check if PR already exists
          existing_pr=$(gh pr list --repo "$TARGET_REPO" --head "$BRANCH_NAME" --json number --jq '.[0].number' 2>/dev/null || echo "")

          if [ -n "$existing_pr" ] && [ "$existing_pr" != "null" ]; then
            echo "PR #${existing_pr} already exists - updating..."
            pr_url="https://github.com/${TARGET_REPO}/pull/${existing_pr}"

            # Update PR body with latest changes
            gh pr edit "$existing_pr" --repo "$TARGET_REPO" --body "$(cat <<EOF
          ## Config Update

          **Source:** [${CONFIG_REPO}](https://github.com/${CONFIG_REPO}) @ \`${CONFIG_SHA}\`

          ### Changes

          \`\`\`
          ${DIFF_STAT}
          \`\`\`

          ### Files Updated

          \`\`\`
          ${CHANGED_FILES}
          \`\`\`

          ### Review Checklist

          - [ ] Review hookify rule changes
          - [ ] Check settings.json permissions
          - [ ] Verify no project-specific configs overwritten
          - [ ] Test rules don't break development workflow

          ---

          Generated by [claude-config-sync](https://github.com/apps/claude-config-sync)
          EOF
          )"
          else
            echo "Creating new PR..."
            pr_url=$(gh pr create \
              --repo "$TARGET_REPO" \
              --head "$BRANCH_NAME" \
              --title "chore(config): update Claude config" \
              --body "$(cat <<EOF
          ## Config Update

          **Source:** [${CONFIG_REPO}](https://github.com/${CONFIG_REPO}) @ \`${CONFIG_SHA}\`

          ### Changes

          \`\`\`
          ${DIFF_STAT}
          \`\`\`

          ### Files Updated

          \`\`\`
          ${CHANGED_FILES}
          \`\`\`

          ### Review Checklist

          - [ ] Review hookify rule changes
          - [ ] Check settings.json permissions
          - [ ] Verify no project-specific configs overwritten
          - [ ] Test rules don't break development workflow

          ---

          Generated by [claude-config-sync](https://github.com/apps/claude-config-sync)
          EOF
          )")
          fi

          echo "PR: ${pr_url}"

          # Try to enable automerge
          if gh pr merge "$pr_url" --auto --squash --delete-branch 2>/dev/null; then
            echo "Automerge enabled"
          else
            echo "Automerge not available (may need to be enabled on repo)"
          fi

      - name: Update dashboard issue
        if: always()
        env:
          GH_TOKEN: ${{ steps.app-token.outputs.token }}
          CHANGED: ${{ steps.sync.outputs.changed }}
          CONFIG_REPO: ${{ github.repository }}
          CONFIG_SHA: ${{ steps.version.outputs.sha || 'N/A' }}
          TARGET_REPO: ${{ matrix.repo }}
        run: |
          TITLE="Claude Config Sync Dashboard"
          TIMESTAMP=$(date -u +"%Y-%m-%d %H:%M:%S UTC")

          if [ "$CHANGED" = "true" ]; then
            STATUS="Synced (check PRs)"
          else
            STATUS="Up to date"
          fi

          body="$(cat <<EOF
          # Claude Config Sync Dashboard

          This issue tracks config sync from the central claude-config repository.

          ## Status

          | Field | Value |
          |-------|-------|
          | Last sync | ${TIMESTAMP} |
          | Config version | \`${CONFIG_SHA}\` |
          | Status | ${STATUS} |

          ## Actions

          - [ ] **Request sync now** - Check this box to trigger a sync

          ## Configuration

          To opt out of specific synced files, create \`.claude/.sync-config.yaml\`:

          \`\`\`yaml
          exclude_categories:
            - commands  # Don't sync common-*.md commands

          exclude_files:
            - "hookify.common-block-kubectl-describe-secrets.local.md"
          \`\`\`

          ---
          Managed by [claude-config-sync](https://github.com/apps/claude-config-sync)
          EOF
          )"

          # Find existing dashboard issue
          existing=$(gh issue list --repo "$TARGET_REPO" --search "\"${TITLE}\" in:title" --state open --json number --jq '.[0].number' 2>/dev/null || echo "")

          if [ -n "$existing" ] && [ "$existing" != "null" ]; then
            gh issue edit "$existing" --repo "$TARGET_REPO" --body "$body" 2>/dev/null || true
          else
            gh issue create --repo "$TARGET_REPO" --title "$TITLE" --body "$body" 2>/dev/null || true
          fi

  summary:
    needs: [discover, sync]
    if: always()
    runs-on: ubuntu-latest
    steps:
      - name: Generate summary
        env:
          MATRIX: ${{ needs.discover.outputs.matrix }}
          HAS_REPOS: ${{ needs.discover.outputs.has-repos }}
          SYNC_RESULT: ${{ needs.sync.result }}
          TARGET_REPOS: ${{ inputs.target_repos }}
        run: |
          {
            echo "## Config Sync Summary"
            echo ""

            if [ "$HAS_REPOS" != "true" ]; then
              echo "No repositories found to sync."
              exit 0
            fi

            # Count repos from matrix
            repo_count=$(echo "$MATRIX" | jq '.include | length')

            echo "| Metric | Value |"
            echo "|--------|-------|"
            echo "| Repositories | ${repo_count} |"

            if [ -n "$TARGET_REPOS" ]; then
              echo "| Mode | Single-repo |"
              echo "| Target | \`${TARGET_REPOS}\` |"
            else
              echo "| Mode | All-repos |"
            fi

            case "$SYNC_RESULT" in
              success)
                echo "| Status | All synced |"
                ;;
              failure)
                echo "| Status | Some failed |"
                ;;
              cancelled)
                echo "| Status | Cancelled |"
                ;;
              skipped)
                echo "| Status | Skipped |"
                ;;
              *)
                echo "| Status | ${SYNC_RESULT:-Unknown} |"
                ;;
            esac
          } >> "$GITHUB_STEP_SUMMARY"
